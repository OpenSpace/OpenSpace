// This file has been auto-generated by the codegen tool
//
// Under **no** circumstances change this file manually as any change will be
// automatically overwritten. Instead change the struct tagged with "codegen::Dictionary"
// or the enum class tagged with "codegen::stringify" in the main file from which he code
// in this file was generated.
//
// If a compiler error brought you into this file, a struct tagged with
// "codegen::Dictionary" or an enum class tagged with "codegen::stringify" was changed
// without the codegen tool being run again.

namespace codegen {

template<typename T> [[maybe_unused]] openspace::documentation::Documentation doc(std::string, [[maybe_unused]] openspace::documentation::Documentation parentDoc = openspace::documentation::Documentation()) {
    static_assert(sizeof(T) == 0);
    return openspace::documentation::Documentation();
}

template <> [[maybe_unused]] openspace::documentation::Documentation doc<Parameters>(std::string id, openspace::documentation::Documentation parentDoc) {
    using namespace openspace::documentation;

    TableVerifier codegen_Parameters_content;
    TableVerifier* codegen_Parameters = &codegen_Parameters_content;
    codegen_Parameters->documentations.push_back({"VerticalFov",new DoubleVerifier,Optional::Yes,VerticalFovInfo.description});

    openspace::documentation::Documentation d = { "WwtCommunicator", std::move(id), std::move(codegen_Parameters->documentations) };

    // Move the entries from the parent doc into this one
    d.entries.insert(d.entries.begin(), parentDoc.entries.begin(), parentDoc.entries.end());

    return d;
}

namespace internal {

template<typename T> [[maybe_unused]] void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); }

template<typename T> [[maybe_unused]] void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val);
[[maybe_unused]] void bakeTo(const ghoul::Dictionary& d, std::string_view key, double* val) { *val = d.value<double>(key); }

template<typename T> [[maybe_unused]] void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val) {
    if (d.hasKey(key)) {
        T v;
        bakeTo(d, key, &v);
        *val = v;
    }
    else {
        *val = std::nullopt;
    }
}

} // namespace internal

template<typename T> [[maybe_unused]] T bake(const ghoul::Dictionary&) { static_assert(sizeof(T) == 0); }

template <> [[maybe_unused]] Parameters bake<Parameters>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<Parameters>("Parameters"), dict, "WwtCommunicator");
    Parameters res;
    internal::bakeTo(dict, "VerticalFov", &res.verticalFov);
    return res;
}

} // namespace codegen

