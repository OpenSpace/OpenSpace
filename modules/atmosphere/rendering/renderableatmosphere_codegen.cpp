
// This file has been auto-generated by the codegen tool by running codegen either
// directly or indirectly on:  renderableatmosphere.cpp
//
// Do not change this file manually as any change will be automatically overwritten,
// instead change the struct tagged with "codegen::Dictionary" in the main file from which
// the code in this file was generated.
//
// If a compiler error brought you here, a struct tagged with "codegen::Dictionary"
// was changed without the codegen tool being run again.

namespace codegen {
template <typename T> openspace::documentation::Documentation doc() {
    static_assert(sizeof(T) == 0); // This should never be called
}
template <> openspace::documentation::Documentation doc<openspace::RenderableAtmosphere>() {
    using namespace openspace::documentation;
    TableVerifier* codegen_Parameters = new TableVerifier;
    TableVerifier* codegen_Parameters_ShadowGroup = new TableVerifier;
    TableVerifier* codegen_Parameters_ShadowGroup_SourceElement = new TableVerifier;
    codegen_Parameters_ShadowGroup_SourceElement->documentations.push_back({"Name",new StringVerifier,Optional::No,"The scene graph node name of the source"});
    codegen_Parameters_ShadowGroup_SourceElement->documentations.push_back({"Radius",new DoubleVerifier,Optional::No,"The radius of the object in meters"});
    codegen_Parameters_ShadowGroup->documentations.push_back({"Sources",new TableVerifier({{"*",codegen_Parameters_ShadowGroup_SourceElement,Optional::Yes, "Individual light sources"}})
,Optional::No,"A list of light sources"});
    TableVerifier* codegen_Parameters_ShadowGroup_CasterElement = new TableVerifier;
    codegen_Parameters_ShadowGroup_CasterElement->documentations.push_back({"Name",new StringVerifier,Optional::No,"The scene graph node name of the source"});
    codegen_Parameters_ShadowGroup_CasterElement->documentations.push_back({"Radius",new DoubleVerifier,Optional::No,"The radius of the object in meters"});
    codegen_Parameters_ShadowGroup->documentations.push_back({"Casters",new TableVerifier({{"*",codegen_Parameters_ShadowGroup_CasterElement,Optional::Yes, "Individual shadow casters"}})
,Optional::No,"A list of objects that cast light on this atmosphere"});
    codegen_Parameters->documentations.push_back({"ShadowGroup",codegen_Parameters_ShadowGroup,Optional::Yes,"Declares shadow groups, meaning which nodes are considered in shadow calculations"});
    codegen_Parameters->documentations.push_back({"AtmosphereHeight",new DoubleVerifier,Optional::No,AtmosphereHeightInfo.description});
    codegen_Parameters->documentations.push_back({"PlanetRadius",new DoubleVerifier,Optional::No,"The radius of the planet in meters"});
    codegen_Parameters->documentations.push_back({"PlanetAverageGroundReflectance",new DoubleVerifier,Optional::No,""});
    codegen_Parameters->documentations.push_back({"SunIntensity",new DoubleVerifier,Optional::Yes,SunIntensityInfo.description});
    codegen_Parameters->documentations.push_back({"MieScatteringExtinctionPropCoefficient",new DoubleVerifier,Optional::Yes,MieScatteringExtinctionPropCoeffInfo.description});
    codegen_Parameters->documentations.push_back({"GroundRadianceEmission",new DoubleVerifier,Optional::No,GroundRadianceEmittioninfo.description});
    TableVerifier* codegen_Parameters_Rayleigh = new TableVerifier;
    TableVerifier* codegen_Parameters_Rayleigh_Coefficients = new TableVerifier;
    codegen_Parameters_Rayleigh_Coefficients->documentations.push_back({"Wavelengths",new DoubleVector3Verifier,Optional::No,""});
    codegen_Parameters_Rayleigh_Coefficients->documentations.push_back({"Scattering",new DoubleVector3Verifier,Optional::No,""});
    codegen_Parameters_Rayleigh->documentations.push_back({"Coefficients",codegen_Parameters_Rayleigh_Coefficients,Optional::No,""});
    codegen_Parameters_Rayleigh->documentations.push_back({"H_R",new DoubleVerifier,Optional::No,""});
    codegen_Parameters->documentations.push_back({"Rayleigh",codegen_Parameters_Rayleigh,Optional::No,""});
    TableVerifier* codegen_Parameters_Ozone = new TableVerifier;
    TableVerifier* codegen_Parameters_Ozone_Coefficients = new TableVerifier;
    codegen_Parameters_Ozone_Coefficients->documentations.push_back({"Extinction",new DoubleVector3Verifier,Optional::Yes,""});
    codegen_Parameters_Ozone->documentations.push_back({"Coefficients",codegen_Parameters_Ozone_Coefficients,Optional::Yes,""});
    codegen_Parameters_Ozone->documentations.push_back({"H_O",new DoubleVerifier,Optional::Yes,""});
    codegen_Parameters->documentations.push_back({"Ozone",codegen_Parameters_Ozone,Optional::Yes,""});
    TableVerifier* codegen_Parameters_Mie = new TableVerifier;
    TableVerifier* codegen_Parameters_Mie_Coefficients = new TableVerifier;
    codegen_Parameters_Mie_Coefficients->documentations.push_back({"Scattering",new DoubleVector3Verifier,Optional::No,""});
    codegen_Parameters_Mie_Coefficients->documentations.push_back({"Extinction",new DoubleVector3Verifier,Optional::No,""});
    codegen_Parameters_Mie->documentations.push_back({"Coefficients",codegen_Parameters_Mie_Coefficients,Optional::No,""});
    codegen_Parameters_Mie->documentations.push_back({"H_M",new DoubleVerifier,Optional::No,""});
    codegen_Parameters_Mie->documentations.push_back({"G",new InRangeVerifier<DoubleVerifier>(-1.0, 1.0),Optional::No,""});
    codegen_Parameters->documentations.push_back({"Mie",codegen_Parameters_Mie,Optional::No,""});
    TableVerifier* codegen_Parameters_ATMDebug = new TableVerifier;
    codegen_Parameters_ATMDebug->documentations.push_back({"PreCalculatedTextureScale",new InRangeVerifier<DoubleVerifier>(0.0, 1.0),Optional::Yes,""});
    codegen_Parameters_ATMDebug->documentations.push_back({"SaveCalculatedTextures",new BoolVerifier,Optional::Yes,""});
    codegen_Parameters->documentations.push_back({"Debug",codegen_Parameters_ATMDebug,Optional::Yes,""});

    openspace::documentation::Documentation d = {
        "RenderableAtmosphere",
        "RenderableAtmosphere",
        std::move(codegen_Parameters->documentations)
    };
    delete codegen_Parameters;
    return d;
}
} // namespace codegen


namespace codegen {
namespace internal {
template<typename T> void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); } // This should never be called
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val);
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val);
void bakeTo(const ghoul::Dictionary& d, std::string_view key, bool* val) { *val = d.value<bool>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, double* val) { *val = d.value<double>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, float* val) { *val = static_cast<float>(d.value<double>(key)); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec3* val) { *val = d.value<glm::dvec3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::vec3* val) { *val = d.value<glm::dvec3>(key); }

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val) {
    if (d.hasKey(key)) {
        T v;
        bakeTo(d, key, &v);
        *val = v;
    }
    else *val = std::nullopt;
}
void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::string* val) { *val = d.value<std::string>(key); }

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val) {
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    std::vector<std::string_view> keys = dict.keys();
    val->reserve(keys.size());
    for (size_t i = 0; i < dict.size(); ++i) {
        T v;
        bakeTo(dict, keys[i], &v);
        val->push_back(std::move(v));
    }
}
template <> void bakeTo<Parameters::ShadowGroup::SourceElement>(const ghoul::Dictionary& d, std::string_view key, Parameters::ShadowGroup::SourceElement* val) {
    Parameters::ShadowGroup::SourceElement& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Name", &res.name);
    internal::bakeTo(dict, "Radius", &res.radius);
}
template <> void bakeTo<Parameters::ShadowGroup::CasterElement>(const ghoul::Dictionary& d, std::string_view key, Parameters::ShadowGroup::CasterElement* val) {
    Parameters::ShadowGroup::CasterElement& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Name", &res.name);
    internal::bakeTo(dict, "Radius", &res.radius);
}
template <> void bakeTo<Parameters::ShadowGroup>(const ghoul::Dictionary& d, std::string_view key, Parameters::ShadowGroup* val) {
    Parameters::ShadowGroup& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Sources", &res.sources);
    internal::bakeTo(dict, "Casters", &res.casters);
}
template <> void bakeTo<Parameters::Rayleigh::Coefficients>(const ghoul::Dictionary& d, std::string_view key, Parameters::Rayleigh::Coefficients* val) {
    Parameters::Rayleigh::Coefficients& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Wavelengths", &res.wavelengths);
    internal::bakeTo(dict, "Scattering", &res.scattering);
}
template <> void bakeTo<Parameters::Rayleigh>(const ghoul::Dictionary& d, std::string_view key, Parameters::Rayleigh* val) {
    Parameters::Rayleigh& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Coefficients", &res.coefficients);
    internal::bakeTo(dict, "H_R", &res.heightScale);
}
template <> void bakeTo<Parameters::Ozone::Coefficients>(const ghoul::Dictionary& d, std::string_view key, Parameters::Ozone::Coefficients* val) {
    Parameters::Ozone::Coefficients& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Extinction", &res.extinction);
}
template <> void bakeTo<Parameters::Ozone>(const ghoul::Dictionary& d, std::string_view key, Parameters::Ozone* val) {
    Parameters::Ozone& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Coefficients", &res.coefficients);
    internal::bakeTo(dict, "H_O", &res.heightScale);
}
template <> void bakeTo<Parameters::Mie::Coefficients>(const ghoul::Dictionary& d, std::string_view key, Parameters::Mie::Coefficients* val) {
    Parameters::Mie::Coefficients& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Scattering", &res.scattering);
    internal::bakeTo(dict, "Extinction", &res.extinction);
}
template <> void bakeTo<Parameters::Mie>(const ghoul::Dictionary& d, std::string_view key, Parameters::Mie* val) {
    Parameters::Mie& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Coefficients", &res.coefficients);
    internal::bakeTo(dict, "H_M", &res.heightScale);
    internal::bakeTo(dict, "G", &res.phaseConstant);
}
template <> void bakeTo<Parameters::ATMDebug>(const ghoul::Dictionary& d, std::string_view key, Parameters::ATMDebug* val) {
    Parameters::ATMDebug& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "PreCalculatedTextureScale", &res.preCalculatedTextureScale);
    internal::bakeTo(dict, "SaveCalculatedTextures", &res.saveCalculatedTextures);
}

} // namespace internal

template <typename T> T bake(const ghoul::Dictionary&) { static_assert(sizeof(T) == 0); };
template <> Parameters bake<Parameters>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<openspace::RenderableAtmosphere>(), dict, "RenderableAtmosphere");
    Parameters res;
    internal::bakeTo(dict, "ShadowGroup", &res.shadowGroup);
    internal::bakeTo(dict, "AtmosphereHeight", &res.atmosphereHeight);
    internal::bakeTo(dict, "PlanetRadius", &res.planetRadius);
    internal::bakeTo(dict, "PlanetAverageGroundReflectance", &res.planetAverageGroundReflectance);
    internal::bakeTo(dict, "SunIntensity", &res.sunIntensity);
    internal::bakeTo(dict, "MieScatteringExtinctionPropCoefficient", &res.mieScatteringExtinctionPropCoefficient);
    internal::bakeTo(dict, "GroundRadianceEmission", &res.groundRadianceEmission);
    internal::bakeTo(dict, "Rayleigh", &res.rayleigh);
    internal::bakeTo(dict, "Ozone", &res.ozone);
    internal::bakeTo(dict, "Mie", &res.mie);
    internal::bakeTo(dict, "Debug", &res.debug);
    return res;
}
} // namespace codegen
