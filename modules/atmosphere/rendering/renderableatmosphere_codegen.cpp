
// This file has been auto-generated by the codegen tool by running
// codegen.exe -file C:\Development\OpenSpace\modules\atmosphere\rendering\renderableatmosphere.cpp
// Do not change this file manually
//
// If a compiler error brought you here, a struct tagged with [[codegen::Dictionary]]
// has been changed without the codegen tool being run again

namespace codegen {
template <typename T> documentation::Documentation doc() {
    static_assert(sizeof(T) == 0); // This should never be called
}
template <> documentation::Documentation doc<RenderableAtmosphere>() {
    using namespace documentation;
    TableVerifier* codegen_Parameters = new TableVerifier;
    TableVerifier* codegen_Parameters_ShadowGroup = new TableVerifier;
    TableVerifier* codegen_Parameters_ShadowGroup_SourceElement = new TableVerifier;
    codegen_Parameters_ShadowGroup_SourceElement->documentations.push_back({"Name",new StringVerifier,Optional::No,"The scene graph node name of the source"});
    codegen_Parameters_ShadowGroup_SourceElement->documentations.push_back({"Radius",new DoubleVerifier,Optional::No,"The radius of the object in meters"});
    codegen_Parameters_ShadowGroup->documentations.push_back({"Sources",new TableVerifier({{"*",codegen_Parameters_ShadowGroup_SourceElement,Optional::Yes, "Individual light sources"}})
,Optional::No,"A list of light sources"});
    TableVerifier* codegen_Parameters_ShadowGroup_CasterElement = new TableVerifier;
    codegen_Parameters_ShadowGroup_CasterElement->documentations.push_back({"Name",new StringVerifier,Optional::No,"The scene graph node name of the source"});
    codegen_Parameters_ShadowGroup_CasterElement->documentations.push_back({"Radius",new DoubleVerifier,Optional::No,"The radius of the object in meters"});
    codegen_Parameters_ShadowGroup->documentations.push_back({"Casters",new TableVerifier({{"*",codegen_Parameters_ShadowGroup_CasterElement,Optional::Yes, "Individual shadow casters"}})
,Optional::No,"A list of objects that cast light on this atmosphere"});
    codegen_Parameters->documentations.push_back({"ShadowGroup",codegen_Parameters_ShadowGroup,Optional::Yes,"Declares shadow groups, meaning which nodes are considered in shadow calculations"});
    codegen_Parameters->documentations.push_back({"AtmosphereHeight",new DoubleVerifier,Optional::No,AtmosphereHeightInfo.description});
    codegen_Parameters->documentations.push_back({"PlanetRadius",new DoubleVerifier,Optional::No,"The radius of the planet in meters"});
    codegen_Parameters->documentations.push_back({"PlanetAverageGroundReflectance",new DoubleVerifier,Optional::No,""});
    codegen_Parameters->documentations.push_back({"SunIntensity",new DoubleVerifier,Optional::Yes,SunIntensityInfo.description});
    codegen_Parameters->documentations.push_back({"MieScatteringExtinctionPropCoefficient",new DoubleVerifier,Optional::Yes,MieScatteringExtinctionPropCoeffInfo.description});
    codegen_Parameters->documentations.push_back({"GroundRadianceEmission",new DoubleVerifier,Optional::No,GroundRadianceEmittioninfo.description});
    TableVerifier* codegen_Parameters_Rayleigh = new TableVerifier;
    TableVerifier* codegen_Parameters_Rayleigh_Coefficients = new TableVerifier;
    codegen_Parameters_Rayleigh_Coefficients->documentations.push_back({"Wavelengths",new DoubleVector3Verifier,Optional::No,""});
    codegen_Parameters_Rayleigh_Coefficients->documentations.push_back({"Scattering",new DoubleVector3Verifier,Optional::No,""});
    codegen_Parameters_Rayleigh->documentations.push_back({"Coefficients",codegen_Parameters_Rayleigh_Coefficients,Optional::No,""});
    codegen_Parameters_Rayleigh->documentations.push_back({"H_R",new DoubleVerifier,Optional::No,""});
    codegen_Parameters->documentations.push_back({"Rayleigh",codegen_Parameters_Rayleigh,Optional::No,""});
    TableVerifier* codegen_Parameters_Ozone = new TableVerifier;
    TableVerifier* codegen_Parameters_Ozone_Coefficients = new TableVerifier;
    codegen_Parameters_Ozone_Coefficients->documentations.push_back({"Extinction",new DoubleVector4Verifier,Optional::No,""});
    codegen_Parameters_Ozone->documentations.push_back({"Coefficients",codegen_Parameters_Ozone_Coefficients,Optional::Yes,""});
    codegen_Parameters_Ozone->documentations.push_back({"H_O",new DoubleVerifier,Optional::Yes,""});
    codegen_Parameters->documentations.push_back({"Ozone",codegen_Parameters_Ozone,Optional::Yes,""});
    TableVerifier* codegen_Parameters_Mie = new TableVerifier;
    TableVerifier* codegen_Parameters_Mie_Coefficients = new TableVerifier;
    codegen_Parameters_Mie_Coefficients->documentations.push_back({"Scattering",new DoubleVector3Verifier,Optional::No,""});
    codegen_Parameters_Mie_Coefficients->documentations.push_back({"Extinction",new DoubleVector3Verifier,Optional::No,""});
    codegen_Parameters_Mie->documentations.push_back({"Coefficients",codegen_Parameters_Mie_Coefficients,Optional::No,""});
    codegen_Parameters_Mie->documentations.push_back({"H_M",new DoubleVerifier,Optional::No,""});
    codegen_Parameters_Mie->documentations.push_back({"G",new DoubleVerifier,Optional::No,""});
    codegen_Parameters->documentations.push_back({"Mie",codegen_Parameters_Mie,Optional::No,""});
    TableVerifier* codegen_Parameters_ATMDebug = new TableVerifier;
    codegen_Parameters_ATMDebug->documentations.push_back({"PreCalculatedTextureScale",new DoubleVerifier,Optional::Yes,""});
    codegen_Parameters_ATMDebug->documentations.push_back({"SaveCalculatedTextures",new BoolVerifier,Optional::Yes,""});
    codegen_Parameters->documentations.push_back({"Debug",codegen_Parameters_ATMDebug,Optional::Yes,""});

    documentation::Documentation d;
    d.name="RenderableAtmosphere";
    d.id="RenderableAtmosphere";
    d.entries=std::move(codegen_Parameters->documentations);
    delete codegen_Parameters;
    return d;
}
} // namespace codegen


namespace codegen {
template<typename T> void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); } // This should never be called
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, bool* val) { *val = d.value<bool>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, int* val) { *val = static_cast<int>(d.value<double>(key)); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, double* val) { *val = d.value<double>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::string* val) { *val = d.value<std::string>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::ivec2* val) { *val = d.value<glm::dvec2>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::ivec3* val) { *val = d.value<glm::dvec3>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::ivec4* val) { *val = d.value<glm::dvec4>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec2* val) { *val = d.value<glm::dvec2>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec3* val) { *val = d.value<glm::dvec3>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec4* val) { *val = d.value<glm::dvec4>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat2x2* val) { *val = d.value<glm::dmat2x2>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat2x3* val) { *val = d.value<glm::dmat2x3>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat2x4* val) { *val = d.value<glm::dmat2x4>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat3x2* val) { *val = d.value<glm::dmat3x2>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat3x3* val) { *val = d.value<glm::dmat3x3>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat3x4* val) { *val = d.value<glm::dmat3x4>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat4x2* val) { *val = d.value<glm::dmat4x2>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat4x3* val) { *val = d.value<glm::dmat4x3>(key); }
template<> void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat4x4* val) { *val = d.value<glm::dmat4x4>(key); }
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val) {
    if (d.hasKey(key)) {
        T v;
        bakeTo(d, key, &v);
        *val = std::move(v);
    }
    else *val = std::nullopt;
}
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val) {
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    std::vector<std::string_view> keys = dict.keys();
    val->reserve(keys.size());
    for (size_t i=0;i<dict.size();++i) {
        T v; bakeTo(dict, keys[i], &v); val->push_back(std::move(v));
    }
}
template <> void bakeTo<Parameters::ShadowGroup::SourceElement>(const ghoul::Dictionary& d, std::string_view key, Parameters::ShadowGroup::SourceElement* val) {
    Parameters::ShadowGroup::SourceElement res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Name", &res.name);
    bakeTo(dict, "Radius", &res.radius);
    *val = res;
}
template <> void bakeTo<Parameters::ShadowGroup::CasterElement>(const ghoul::Dictionary& d, std::string_view key, Parameters::ShadowGroup::CasterElement* val) {
    Parameters::ShadowGroup::CasterElement res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Name", &res.name);
    bakeTo(dict, "Radius", &res.radius);
    *val = res;
}
template <> void bakeTo<Parameters::ShadowGroup>(const ghoul::Dictionary& d, std::string_view key, Parameters::ShadowGroup* val) {
    Parameters::ShadowGroup res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Sources", &res.sources);
    bakeTo(dict, "Casters", &res.casters);
    *val = res;
}
template <> void bakeTo<Parameters::Rayleigh::Coefficients>(const ghoul::Dictionary& d, std::string_view key, Parameters::Rayleigh::Coefficients* val) {
    Parameters::Rayleigh::Coefficients res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Wavelengths", &res.wavelengths);
    bakeTo(dict, "Scattering", &res.scattering);
    *val = res;
}
template <> void bakeTo<Parameters::Rayleigh>(const ghoul::Dictionary& d, std::string_view key, Parameters::Rayleigh* val) {
    Parameters::Rayleigh res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Coefficients", &res.coefficients);
    bakeTo(dict, "H_R", &res.heightScale);
    *val = res;
}
template <> void bakeTo<Parameters::Ozone::Coefficients>(const ghoul::Dictionary& d, std::string_view key, Parameters::Ozone::Coefficients* val) {
    Parameters::Ozone::Coefficients res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Extinction", &res.extinction);
    *val = res;
}
template <> void bakeTo<Parameters::Ozone>(const ghoul::Dictionary& d, std::string_view key, Parameters::Ozone* val) {
    Parameters::Ozone res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Coefficients", &res.coefficients);
    bakeTo(dict, "H_O", &res.heightScale);
    *val = res;
}
template <> void bakeTo<Parameters::Mie::Coefficients>(const ghoul::Dictionary& d, std::string_view key, Parameters::Mie::Coefficients* val) {
    Parameters::Mie::Coefficients res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Scattering", &res.scattering);
    bakeTo(dict, "Extinction", &res.extinction);
    *val = res;
}
template <> void bakeTo<Parameters::Mie>(const ghoul::Dictionary& d, std::string_view key, Parameters::Mie* val) {
    Parameters::Mie res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "Coefficients", &res.coefficients);
    bakeTo(dict, "H_M", &res.heightScale);
    bakeTo(dict, "G", &res.phaseConstant);
    *val = res;
}
template <> void bakeTo<Parameters::ATMDebug>(const ghoul::Dictionary& d, std::string_view key, Parameters::ATMDebug* val) {
    Parameters::ATMDebug res;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    bakeTo(dict, "PreCalculatedTextureScale", &res.preCalculatedTextureScale);
    bakeTo(dict, "SaveCalculatedTextures", &res.saveCalculatedTextures);
    *val = res;
}

template <typename T> T bake(const ghoul::Dictionary& dict) { static_assert(sizeof(T) == 0); };
template <> Parameters bake<Parameters>(const ghoul::Dictionary& dict) {
    documentation::testSpecificationAndThrow(codegen::doc<RenderableAtmosphere>(), dict, "RenderableAtmosphere");
    Parameters res;
    bakeTo(dict, "ShadowGroup", &res.shadowGroup);
    bakeTo(dict, "AtmosphereHeight", &res.atmosphereHeight);
    bakeTo(dict, "PlanetRadius", &res.planetRadius);
    bakeTo(dict, "PlanetAverageGroundReflectance", &res.planetAverageGroundReflectance);
    bakeTo(dict, "SunIntensity", &res.sunIntensity);
    bakeTo(dict, "MieScatteringExtinctionPropCoefficient", &res.mieScatteringExtinctionPropCoefficient);
    bakeTo(dict, "GroundRadianceEmission", &res.groundRadianceEmission);
    bakeTo(dict, "Rayleigh", &res.rayleigh);
    bakeTo(dict, "Ozone", &res.ozone);
    bakeTo(dict, "Mie", &res.mie);
    bakeTo(dict, "Debug", &res.debug);
    return res;
}
} // namespace codegen
