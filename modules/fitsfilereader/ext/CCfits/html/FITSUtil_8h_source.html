<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CCfits: FITSUtil.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CCfits
   &#160;<span id="projectnumber">2.5</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">FITSUtil.h</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//      Astrophysics Science Division,</span>
<a name="l00002"></a>00002 <span class="comment">//      NASA/ Goddard Space Flight Center</span>
<a name="l00003"></a>00003 <span class="comment">//      HEASARC</span>
<a name="l00004"></a>00004 <span class="comment">//      http://heasarc.gsfc.nasa.gov</span>
<a name="l00005"></a>00005 <span class="comment">//      e-mail: ccfits@legacy.gsfc.nasa.gov</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">//      Original author: Ben Dorman</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#ifndef FITSUTIL_H</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#define FITSUTIL_H 1</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#include &quot;CCfits.h&quot;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="comment">// functional</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00015"></a>00015 <span class="comment">// complex</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00017"></a>00017 <span class="comment">// valarray</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;valarray&gt;</span>
<a name="l00019"></a>00019 <span class="comment">// vector</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00021"></a>00021 <span class="comment">// string</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00023"></a>00023 <span class="comment">// FitsError</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;FitsError.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="keyword">namespace </span>CCfits {
<a name="l00029"></a>00029 
<a name="l00030"></a>00030   <span class="keyword">namespace </span>FITSUtil {
<a name="l00031"></a>00031 
<a name="l00280"></a>00280 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span><span class="preprocessor">#include &quot;MSconfig.h&quot;</span> <span class="comment">// for truncation double to float warning</span>
<a name="l00282"></a>00282 <span class="preprocessor">#endif</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span>
<a name="l00284"></a>00284      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00285"></a>00285     <span class="keywordtype">void</span> swap(T&amp; left,T&amp; right);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00288"></a>00288     <span class="keywordtype">void</span> swap(std::vector&lt;T&gt;&amp; left, std::vector&lt;T&gt;&amp; right);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290     <span class="keywordtype">string</span> lowerCase(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; inputString);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     <span class="keywordtype">string</span> upperCase(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; inputString);
<a name="l00293"></a>00293 
<a name="l00294"></a>00294   <span class="comment">// Check if a file name includes an image compression specifier,</span>
<a name="l00295"></a>00295   <span class="comment">// and return its location if it exists.</span>
<a name="l00296"></a>00296     string::size_type checkForCompressString(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; fileName);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298   <span class="keyword">struct </span>InvalidConversion : <span class="keyword">public</span> FitsException
<a name="l00299"></a>00299   {
<a name="l00300"></a>00300                 InvalidConversion(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; diag, <span class="keywordtype">bool</span> silent=<span class="keyword">false</span>);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   };
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="keyword">struct </span>MatchStem : <span class="keyword">public</span> std::binary_function&lt;string,string,bool&gt;
<a name="l00305"></a>00305   {
<a name="l00306"></a>00306           <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; left, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; right) <span class="keyword">const</span>;
<a name="l00307"></a>00307   };
<a name="l00308"></a>00308 
<a name="l00309"></a>00309   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">double</span> d1(0);
<a name="l00310"></a>00310   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">float</span>  f1(0);
<a name="l00311"></a>00311   <span class="keyword">static</span> <span class="keyword">const</span>  std::complex&lt;float&gt; c1(0.);
<a name="l00312"></a>00312   <span class="keyword">static</span> <span class="keyword">const</span>  std::complex&lt;double&gt; d2(0.);
<a name="l00313"></a>00313   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">string</span> s1(<span class="stringliteral">&quot;&quot;</span>);
<a name="l00314"></a>00314   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">int</span>    i1(0);
<a name="l00315"></a>00315   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  u1(0);        
<a name="l00316"></a>00316   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">long</span> l1(0);
<a name="l00317"></a>00317   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ul1(0);
<a name="l00318"></a>00318   <span class="keyword">static</span> <span class="keyword">const</span>  LONGLONG ll1(0);
<a name="l00319"></a>00319   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">short</span> s2(0);
<a name="l00320"></a>00320   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> us1(0); 
<a name="l00321"></a>00321   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">bool</span> b1(<span class="keyword">false</span>);
<a name="l00322"></a>00322   <span class="keyword">static</span> <span class="keyword">const</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b2(0);  
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   <span class="keywordtype">char</span>** CharArray(<span class="keyword">const</span> std::vector&lt;string&gt;&amp; inArray);
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="keywordtype">string</span> FITSType2String( <span class="keywordtype">int</span> typeInt );
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 
<a name="l00329"></a>00329   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S, <span class="keyword">typename</span> T&gt; 
<a name="l00330"></a>00330   <span class="keywordtype">void</span> fill(std::vector&lt;S&gt;&amp; outArray, <span class="keyword">const</span> std::vector&lt;T&gt;&amp; inArray,<span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S, <span class="keyword">typename</span> T&gt; 
<a name="l00333"></a>00333   <span class="keywordtype">void</span> fill(std::valarray&lt;S&gt;&amp; outArray, <span class="keyword">const</span> std::valarray&lt;T&gt;&amp; inArray);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S, <span class="keyword">typename</span> T&gt; 
<a name="l00336"></a>00336   <span class="keywordtype">void</span> fill(std::valarray&lt;S&gt;&amp; outArray, <span class="keyword">const</span> std::vector&lt;T&gt;&amp; inArray,<span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S, <span class="keyword">typename</span> T&gt; 
<a name="l00340"></a>00340   <span class="keywordtype">void</span> fill(std::vector&lt;S&gt;&amp; outArray, <span class="keyword">const</span> std::valarray&lt;T&gt;&amp; inArray);
<a name="l00341"></a>00341 
<a name="l00342"></a>00342   <span class="comment">// VF&lt;-AF</span>
<a name="l00343"></a>00343    <span class="keywordtype">void</span> fill(std::vector&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00344"></a>00344                   <span class="keyword">const</span> std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; inArray);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   <span class="comment">// VF&lt;-AD</span>
<a name="l00347"></a>00347   <span class="keywordtype">void</span> fill(std::vector&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00348"></a>00348                   <span class="keyword">const</span> std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; inArray);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="comment">// VD&lt;-AD</span>
<a name="l00351"></a>00351   <span class="keywordtype">void</span> fill(std::vector&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00352"></a>00352                   <span class="keyword">const</span> std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; inArray);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 
<a name="l00355"></a>00355   <span class="comment">// VD&lt;-AF</span>
<a name="l00356"></a>00356   <span class="keywordtype">void</span> fill(std::vector&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00357"></a>00357                   <span class="keyword">const</span> std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; inArray);
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00360"></a>00360   <span class="keywordtype">void</span> fill(std::vector&lt;string&gt;&amp; outArray, <span class="keyword">const</span> std::vector&lt;T&gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00363"></a>00363   <span class="keywordtype">void</span> fill(std::vector&lt;T&gt;&amp; outArray, <span class="keyword">const</span> std::vector&lt;string&gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt; 
<a name="l00366"></a>00366   <span class="keywordtype">void</span> fill(std::valarray&lt;S&gt;&amp; outArray, <span class="keyword">const</span> std::vector&lt;string&gt;&amp; inArray,<span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="comment">//  template &lt;typename S, typename T&gt;</span>
<a name="l00369"></a>00369 <span class="comment">//  void fill(std::valarray&lt;std::complex&lt;S&gt; &gt;&amp; outArray, const std::valarray&lt;std::complex&lt;T&gt; &gt;&amp; inArray);            </span>
<a name="l00370"></a>00370   <span class="comment">// seems no other way of doing this.</span>
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="comment">// VF&lt;-VF</span>
<a name="l00373"></a>00373 <span class="preprocessor">#ifdef TEMPLATE_AMBIG_DEFECT</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span>  <span class="keywordtype">void</span> fillMSvfvf(std::vector&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00375"></a>00375                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;float&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00376"></a>00376 <span class="preprocessor">#endif</span>
<a name="l00377"></a>00377 <span class="preprocessor"></span>
<a name="l00378"></a>00378   <span class="keywordtype">void</span> fill(std::vector&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00379"></a>00379                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;float&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="comment">// VF&lt;-VD</span>
<a name="l00382"></a>00382 <span class="preprocessor">#ifdef TEMPLATE_AMBIG_DEFECT</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>    <span class="keywordtype">void</span> fillMSvfvd(std::vector&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00384"></a>00384                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;double&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00385"></a>00385 <span class="preprocessor">#endif</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>
<a name="l00387"></a>00387    <span class="keywordtype">void</span> fill(std::vector&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00388"></a>00388                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;double&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00389"></a>00389 
<a name="l00390"></a>00390    <span class="comment">// VD&lt;-VD</span>
<a name="l00391"></a>00391 <span class="preprocessor">#ifdef TEMPLATE_AMBIG_DEFECT</span>
<a name="l00392"></a>00392 <span class="preprocessor"></span> <span class="keywordtype">void</span> fillMSvdvd(std::vector&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00393"></a>00393                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;double&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00394"></a>00394 <span class="preprocessor">#endif</span>
<a name="l00395"></a>00395 <span class="preprocessor"></span>
<a name="l00396"></a>00396    <span class="keywordtype">void</span> fill(std::vector&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00397"></a>00397                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;double&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="preprocessor">#ifdef TEMPLATE_AMBIG_DEFECT</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>  <span class="keywordtype">void</span> fillMSvdvf(std::vector&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00401"></a>00401                                 <span class="keyword">const</span> std::vector&lt;std::complex&lt;float&gt; &gt;&amp; inArray, 
<a name="l00402"></a>00402                         <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00403"></a>00403 <span class="preprocessor">#else</span>
<a name="l00404"></a>00404 <span class="preprocessor"></span>  <span class="keywordtype">void</span> fill(std::vector&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00405"></a>00405                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;float&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00406"></a>00406 <span class="preprocessor">#endif</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>
<a name="l00408"></a>00408   <span class="comment">// AF&lt;-VD</span>
<a name="l00409"></a>00409   <span class="keywordtype">void</span> fill(std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00410"></a>00410                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;double&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   <span class="comment">// AF&lt;-VF</span>
<a name="l00413"></a>00413 <span class="preprocessor">#ifdef TEMPLATE_AMBIG_DEFECT</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span> <span class="keywordtype">void</span> fillMSafvf(std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00415"></a>00415                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;float&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00416"></a>00416 <span class="preprocessor">#else</span>
<a name="l00417"></a>00417 <span class="preprocessor"></span> <span class="keywordtype">void</span> fill(std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00418"></a>00418                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;float&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00419"></a>00419 <span class="preprocessor">#endif</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span>
<a name="l00421"></a>00421  <span class="comment">// AD&lt;-VF</span>
<a name="l00422"></a>00422 <span class="preprocessor">#ifdef TEMPLATE_AMBIG_DEFECT</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span>  <span class="keywordtype">void</span> fillMSadvf(std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00424"></a>00424                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;float&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00425"></a>00425 <span class="preprocessor">#else</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>  <span class="keywordtype">void</span> fill(std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00427"></a>00427                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;float&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00428"></a>00428 <span class="preprocessor">#endif</span>
<a name="l00429"></a>00429 <span class="preprocessor"></span>
<a name="l00430"></a>00430   <span class="comment">// AD&lt;-VD</span>
<a name="l00431"></a>00431 <span class="preprocessor">#ifdef TEMPLATE_AMBIG_DEFECT</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span>  <span class="keywordtype">void</span> fillMSadvd(std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00433"></a>00433                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;double&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00434"></a>00434 <span class="preprocessor">#else</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span>  <span class="keywordtype">void</span> fill(std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; outArray, 
<a name="l00436"></a>00436                   <span class="keyword">const</span> std::vector&lt;std::complex&lt;double&gt; &gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00437"></a>00437 <span class="preprocessor">#endif</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>
<a name="l00439"></a>00439   <span class="comment">// AF&lt;-AF</span>
<a name="l00440"></a>00440   <span class="keywordtype">void</span> fill(std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; outArray,  
<a name="l00441"></a>00441                   <span class="keyword">const</span> std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; inArray);
<a name="l00442"></a>00442   <span class="comment">// AD&lt;-AD</span>
<a name="l00443"></a>00443   <span class="keywordtype">void</span> fill(std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; outArray,  
<a name="l00444"></a>00444                   <span class="keyword">const</span> std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; inArray);
<a name="l00445"></a>00445   <span class="comment">// AF&lt;-AD</span>
<a name="l00446"></a>00446   <span class="keywordtype">void</span> fill(std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; outArray, 
<a name="l00447"></a>00447                   <span class="keyword">const</span> std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; inArray);
<a name="l00448"></a>00448   <span class="comment">// AD&lt;-AF</span>
<a name="l00449"></a>00449   <span class="keywordtype">void</span> fill(std::valarray&lt;std::complex&lt;double&gt; &gt;&amp; outArray,  
<a name="l00450"></a>00450                   <span class="keyword">const</span> std::valarray&lt;std::complex&lt;float&gt; &gt;&amp; inArray);
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="preprocessor">#if TEMPLATE_AMBIG_DEFECT || TEMPLATE_AMBIG7_DEFECT</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span>  <span class="keywordtype">void</span> fillMSvsvs(std::vector&lt;string&gt;&amp; outArray, <span class="keyword">const</span> std::vector&lt;string&gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00454"></a>00454 <span class="preprocessor">#endif</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span>
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="keywordtype">void</span> fill(std::vector&lt;string&gt;&amp; outArray, <span class="keyword">const</span> std::vector&lt;string&gt;&amp; inArray, <span class="keywordtype">size_t</span> first, <span class="keywordtype">size_t</span> last);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S, <span class="keyword">typename</span> T&gt;
<a name="l00460"></a>00460   <span class="keywordtype">string</span> errorMessage(<span class="keyword">const</span> S&amp; out, <span class="keyword">const</span> T&amp; in);
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00465"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchPtrName.html">00465</a>     <span class="keyword">struct </span><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchPtrName.html" title="as for MatchName, only with the input class a pointer.">MatchPtrName</a> : <span class="keyword">public</span> std::binary_function&lt;T,std::string,bool&gt;  <span class="comment">//## Inherits: &lt;unnamed&gt;%39491BC9025D</span>
<a name="l00466"></a>00466     {
<a name="l00467"></a>00467           <span class="comment">//    Parameterized Class MatchPtrName</span>
<a name="l00468"></a>00468           <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> T&amp; left, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; right) <span class="keyword">const</span>;
<a name="l00469"></a>00469 
<a name="l00470"></a>00470       <span class="keyword">public</span>:
<a name="l00471"></a>00471       <span class="keyword">protected</span>:
<a name="l00472"></a>00472       <span class="keyword">private</span>:
<a name="l00473"></a>00473       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00474"></a>00474     };
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 
<a name="l00478"></a>00478     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00479"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchName.html">00479</a>     <span class="keyword">struct </span><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchName.html" title="predicate for classes that have a name attribute; match input string with instance name...">MatchName</a> : <span class="keyword">public</span> std::binary_function&lt;T,std::string,bool&gt;  <span class="comment">//## Inherits: &lt;unnamed&gt;%39491BC50121</span>
<a name="l00480"></a>00480     {
<a name="l00481"></a>00481           <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> T&amp; left, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; right) <span class="keyword">const</span>;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483       <span class="keyword">public</span>:
<a name="l00484"></a>00484       <span class="keyword">protected</span>:
<a name="l00485"></a>00485       <span class="keyword">private</span>:
<a name="l00486"></a>00486       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00487"></a>00487     };
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00492"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchNum.html">00492</a>     <span class="keyword">struct </span><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchNum.html" title="predicate for classes that have an index attribute; match input index with instance value...">MatchNum</a> : <span class="keyword">public</span> std::binary_function&lt;T,int,bool&gt;  <span class="comment">//## Inherits: &lt;unnamed&gt;%39491BCE01C0</span>
<a name="l00493"></a>00493     {
<a name="l00494"></a>00494           <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> T&amp; left, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; right) <span class="keyword">const</span>;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496       <span class="keyword">public</span>:
<a name="l00497"></a>00497       <span class="keyword">protected</span>:
<a name="l00498"></a>00498       <span class="keyword">private</span>:
<a name="l00499"></a>00499       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00500"></a>00500     };
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 
<a name="l00504"></a>00504     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00505"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchType.html">00505</a>     <span class="keyword">struct </span><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchType.html" title="function object that returns the FITS ValueType corresponding to an input intrinsic type...">MatchType</a> 
<a name="l00506"></a>00506     {
<a name="l00507"></a>00507           <a class="code" href="namespaceCCfits.html#a1291594525d4e6fd06698c98a7a7ec2f" title="CCfits value types and their CFITSIO equivalents (in caps)">ValueType</a> operator () ();
<a name="l00508"></a>00508 
<a name="l00509"></a>00509       <span class="keyword">public</span>:
<a name="l00510"></a>00510       <span class="keyword">protected</span>:
<a name="l00511"></a>00511       <span class="keyword">private</span>:
<a name="l00512"></a>00512       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00513"></a>00513     };
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 
<a name="l00516"></a>00516 
<a name="l00517"></a>00517     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00518"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1CVarray.html">00518</a>     <span class="keyword">struct </span><a class="code" href="structCCfits_1_1FITSUtil_1_1CVarray.html" title="Function object class for returning C arrays from standard library objects used in the FITS library i...">CVarray</a> 
<a name="l00519"></a>00519     {
<a name="l00520"></a>00520           T* <a class="code" href="structCCfits_1_1FITSUtil_1_1CVarray.html#a661c853b542621505841646ffb4f9b60" title="operator returning C array for use with scalar column data.">operator () </a>(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; inArray);
<a name="l00521"></a>00521 
<a name="l00522"></a>00522       <span class="keyword">public</span>:
<a name="l00523"></a>00523       <span class="keyword">protected</span>:
<a name="l00524"></a>00524       <span class="keyword">private</span>:
<a name="l00525"></a>00525       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00526"></a>00526     };
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 
<a name="l00530"></a>00530     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00531"></a>00531     <span class="keyword">struct </span>FitsNullValue 
<a name="l00532"></a>00532     {
<a name="l00533"></a>00533           T operator () ();
<a name="l00534"></a>00534 
<a name="l00535"></a>00535       <span class="keyword">public</span>:
<a name="l00536"></a>00536       <span class="keyword">protected</span>:
<a name="l00537"></a>00537       <span class="keyword">private</span>:
<a name="l00538"></a>00538       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00539"></a>00539     };
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00544"></a>00544     <span class="keyword">struct </span>MatchImageType 
<a name="l00545"></a>00545     {
<a name="l00546"></a>00546           ImageType operator () ();
<a name="l00547"></a>00547 
<a name="l00548"></a>00548       <span class="keyword">public</span>:
<a name="l00549"></a>00549       <span class="keyword">protected</span>:
<a name="l00550"></a>00550       <span class="keyword">private</span>:
<a name="l00551"></a>00551       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00552"></a>00552     };
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00557"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchPtrNum.html">00557</a>     <span class="keyword">struct </span><a class="code" href="structCCfits_1_1FITSUtil_1_1MatchPtrNum.html" title="as for MatchNum, only with the input class a pointer.">MatchPtrNum</a> : <span class="keyword">public</span> std::binary_function&lt;T,int,bool&gt;  <span class="comment">//## Inherits: &lt;unnamed&gt;%39491BD3034B</span>
<a name="l00558"></a>00558     {
<a name="l00559"></a>00559           <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> T&amp; left, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; right) <span class="keyword">const</span>;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561       <span class="keyword">public</span>:
<a name="l00562"></a>00562       <span class="keyword">protected</span>:
<a name="l00563"></a>00563       <span class="keyword">private</span>:
<a name="l00564"></a>00564       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00565"></a>00565     };
<a name="l00566"></a>00566     <span class="comment">//  auto_ptr analogue for arrays.</span>
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00571"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html">00571</a>     <span class="keyword">class </span><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html" title="A class that mimics the std:: library auto_ptr class, but works with arrays.">auto_array_ptr</a> 
<a name="l00572"></a>00572     {
<a name="l00573"></a>00573       <span class="keyword">public</span>:
<a name="l00574"></a>00574           <span class="keyword">explicit</span> <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#aa7eff76215f0bd5ac0aec23c39b903fe" title="constructor. allows creation of pointer to null, can be modified by reset()">auto_array_ptr</a> (X* p = 0) <span class="keywordflow">throw</span> ();
<a name="l00575"></a>00575           <span class="keyword">explicit</span> <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#aa7eff76215f0bd5ac0aec23c39b903fe" title="constructor. allows creation of pointer to null, can be modified by reset()">auto_array_ptr</a> (<a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html" title="A class that mimics the std:: library auto_ptr class, but works with arrays.">auto_array_ptr&lt;X&gt;</a>&amp; right) <span class="keywordflow">throw</span> ();
<a name="l00576"></a>00576           <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a53dbf2f60ac2851b86b70dad5619b862" title="destructor.">~auto_array_ptr</a>();
<a name="l00577"></a>00577 
<a name="l00578"></a>00578           <span class="keywordtype">void</span> <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a13ae387ac0d5d498974cc05d5ff878ae" title="assignment operator: transfer of ownership semantics">operator = </a>(<a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html" title="A class that mimics the std:: library auto_ptr class, but works with arrays.">auto_array_ptr&lt;X&gt;</a>&amp; right);
<a name="l00579"></a>00579           X&amp; <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a46abc946300c6b7deaa7e456ba9f1aed" title="deference operator">operator * </a>() <span class="keywordflow">throw</span> ();
<a name="l00580"></a>00580           X&amp; <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a114a298f4d870f74ed1039c6ee41b2b5" title="return a reference to the ith element of the array">operator [] </a>(<span class="keywordtype">size_t</span> i) <span class="keywordflow">throw</span> ();
<a name="l00581"></a>00581           X <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a114a298f4d870f74ed1039c6ee41b2b5" title="return a reference to the ith element of the array">operator [] </a>(<span class="keywordtype">size_t</span> i) <span class="keyword">const</span> <span class="keywordflow">throw</span> ();
<a name="l00582"></a>00582           X* <span class="keyword">get</span> () <span class="keyword">const</span>;
<a name="l00583"></a>00583           X* <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a994e12743b5b7d75b4168ac095a60c1f" title="return underlying content of *this, transferring memory ownership">release</a> () <span class="keywordflow">throw</span> ();
<a name="l00584"></a>00584           X* <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#af2e65ee8fafdd812f2782da2dfea285a" title="change the content of the auto_array_ptr to p">reset</a> (X* p) <span class="keywordflow">throw</span> ();
<a name="l00585"></a>00585           <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">remove</span> (X*&amp; x);
<a name="l00586"></a>00586 
<a name="l00587"></a>00587       <span class="keyword">protected</span>:
<a name="l00588"></a>00588       <span class="keyword">private</span>:
<a name="l00589"></a>00589       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00590"></a>00590         <span class="comment">// Data Members for Class Attributes</span>
<a name="l00591"></a>00591           X* m_p;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     };
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 
<a name="l00596"></a>00596 
<a name="l00597"></a>00597     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00598"></a>00598     <span class="keyword">struct </span>ComparePtrIndex : <span class="keyword">public</span> std::binary_function&lt;T,T,bool&gt;  <span class="comment">//## Inherits: &lt;unnamed&gt;%3B24DB930299</span>
<a name="l00599"></a>00599     {
<a name="l00600"></a>00600           <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> T* left, <span class="keyword">const</span> T* right);
<a name="l00601"></a>00601 
<a name="l00602"></a>00602       <span class="keyword">public</span>:
<a name="l00603"></a>00603       <span class="keyword">protected</span>:
<a name="l00604"></a>00604       <span class="keyword">private</span>:
<a name="l00605"></a>00605       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00606"></a>00606     };
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 
<a name="l00610"></a>00610     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00611"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1CAarray.html">00611</a>     <span class="keyword">struct </span><a class="code" href="structCCfits_1_1FITSUtil_1_1CAarray.html" title="function object returning C array from a valarray. see CVarray for details">CAarray</a> 
<a name="l00612"></a>00612     {
<a name="l00613"></a>00613           T* <a class="code" href="structCCfits_1_1FITSUtil_1_1CAarray.html#a696f1168e9058a218e91ea0ead06693f" title="operator returning C array for use with image data.">operator () </a>(<span class="keyword">const</span> std::valarray&lt;T&gt;&amp; inArray);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615       <span class="keyword">public</span>:
<a name="l00616"></a>00616       <span class="keyword">protected</span>:
<a name="l00617"></a>00617       <span class="keyword">private</span>:
<a name="l00618"></a>00618       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00619"></a>00619     };
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 
<a name="l00623"></a>00623     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00624"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1CVAarray.html">00624</a>     <span class="keyword">struct </span><a class="code" href="structCCfits_1_1FITSUtil_1_1CVAarray.html" title="function object returning C array from a vector of valarrays. see CVarray for details">CVAarray</a> 
<a name="l00625"></a>00625     {
<a name="l00626"></a>00626           T* <a class="code" href="structCCfits_1_1FITSUtil_1_1CVAarray.html#a817543d5a8700ca336a35e62a3223d12" title="operator returning C array for use with vector column data.">operator () </a>(<span class="keyword">const</span> std::vector&lt; std::valarray&lt;T&gt; &gt;&amp; inArray);
<a name="l00627"></a>00627 
<a name="l00628"></a>00628       <span class="keyword">public</span>:
<a name="l00629"></a>00629       <span class="keyword">protected</span>:
<a name="l00630"></a>00630       <span class="keyword">private</span>:
<a name="l00631"></a>00631       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00632"></a>00632     };
<a name="l00633"></a>00633 
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 
<a name="l00636"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1UnrecognizedType.html">00636</a>     <span class="keyword">class </span><a class="code" href="classCCfits_1_1FITSUtil_1_1UnrecognizedType.html" title="exception thrown by MatchType if it encounters data type incompatible with cfitsio.">UnrecognizedType</a> : <span class="keyword">public</span> <a class="code" href="classCCfits_1_1FitsException.html" title="FitsException is the base class for all exceptions thrown by this library.">FitsException</a>  <span class="comment">//## Inherits: &lt;unnamed&gt;%3CE143AB00C6</span>
<a name="l00637"></a>00637     {
<a name="l00638"></a>00638       <span class="keyword">public</span>:
<a name="l00639"></a>00639           <a class="code" href="classCCfits_1_1FITSUtil_1_1UnrecognizedType.html" title="exception thrown by MatchType if it encounters data type incompatible with cfitsio.">UnrecognizedType</a> (<span class="keywordtype">string</span> diag, <span class="keywordtype">bool</span> silent = <span class="keyword">true</span>);
<a name="l00640"></a>00640 
<a name="l00641"></a>00641       <span class="keyword">protected</span>:
<a name="l00642"></a>00642       <span class="keyword">private</span>:
<a name="l00643"></a>00643       <span class="keyword">private</span>: <span class="comment">//## implementation</span>
<a name="l00644"></a>00644     };
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchPtrName </span>
<a name="l00647"></a>00647 
<a name="l00648"></a>00648     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00649"></a>00649     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="structCCfits_1_1FITSUtil_1_1MatchPtrName.html" title="as for MatchName, only with the input class a pointer.">MatchPtrName&lt;T&gt;::operator () </a>(<span class="keyword">const</span> T&amp; left, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; right)<span class="keyword"> const</span>
<a name="l00650"></a>00650 <span class="keyword">    </span>{
<a name="l00651"></a>00651        <span class="keywordflow">return</span> left-&gt;name() == right;
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchName </span>
<a name="l00655"></a>00655 
<a name="l00656"></a>00656     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00657"></a>00657     <span class="keyword">inline</span> <span class="keywordtype">bool</span> MatchName&lt;T&gt;::operator () (<span class="keyword">const</span> T&amp; left, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; right)<span class="keyword"> const</span>
<a name="l00658"></a>00658 <span class="keyword">    </span>{
<a name="l00659"></a>00659        <span class="keywordflow">return</span> left.name() == right;
<a name="l00660"></a>00660     }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchNum </span>
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00665"></a>00665     <span class="keyword">inline</span> <span class="keywordtype">bool</span> MatchNum&lt;T&gt;::operator () (<span class="keyword">const</span> T&amp; left, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; right)<span class="keyword"> const</span>
<a name="l00666"></a>00666 <span class="keyword">    </span>{
<a name="l00667"></a>00667     <span class="keywordflow">return</span> left.index() == right;
<a name="l00668"></a>00668     }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchType </span>
<a name="l00671"></a>00671 
<a name="l00672"></a>00672     <span class="comment">// Parameterized Class CCfits::FITSUtil::CVarray </span>
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00675"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1CVarray.html#a661c853b542621505841646ffb4f9b60">00675</a>     <span class="keyword">inline</span> T* <a class="code" href="structCCfits_1_1FITSUtil_1_1CVarray.html#a661c853b542621505841646ffb4f9b60" title="operator returning C array for use with scalar column data.">CVarray&lt;T&gt;::operator () </a>(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; inArray)
<a name="l00676"></a>00676     {
<a name="l00677"></a>00677 
<a name="l00678"></a>00678       <span class="comment">// convert std containers used commonly in FITS to C arrays in an exception</span>
<a name="l00679"></a>00679       <span class="comment">// safe manner that is also clear about resource ownership.      </span>
<a name="l00680"></a>00680       <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html" title="A class that mimics the std:: library auto_ptr class, but works with arrays.">auto_array_ptr&lt;T&gt;</a> pC(<span class="keyword">new</span> T[inArray.size()]);
<a name="l00681"></a>00681       T* c = pC.<a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a6cf9e51e5dd7a9d9d512900465c5ea1f" title="return a token for the underlying content of *this">get</a>();
<a name="l00682"></a>00682       std::copy(inArray.begin(),inArray.end(),&amp;c[0]);
<a name="l00683"></a>00683       <span class="keywordflow">return</span> pC.release();
<a name="l00684"></a>00684     }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="comment">// Parameterized Class CCfits::FITSUtil::FitsNullValue </span>
<a name="l00687"></a>00687 
<a name="l00688"></a>00688     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00689"></a>00689     <span class="keyword">inline</span> T FitsNullValue&lt;T&gt;::operator () ()
<a name="l00690"></a>00690     {
<a name="l00691"></a>00691        <span class="comment">// This works for int types.  Float, complex, and string types </span>
<a name="l00692"></a>00692        <span class="comment">//   are handled below with specialized templates.</span>
<a name="l00693"></a>00693        <span class="keywordflow">return</span> 0;
<a name="l00694"></a>00694     }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchImageType </span>
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchPtrNum </span>
<a name="l00699"></a>00699 
<a name="l00700"></a>00700     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00701"></a>00701     <span class="keyword">inline</span> <span class="keywordtype">bool</span> MatchPtrNum&lt;T&gt;::operator () (<span class="keyword">const</span> T&amp; left, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; right)<span class="keyword"> const</span>
<a name="l00702"></a>00702 <span class="keyword">    </span>{
<a name="l00703"></a>00703     <span class="keywordflow">return</span> left-&gt;index() == right;
<a name="l00704"></a>00704     }
<a name="l00705"></a>00705 
<a name="l00706"></a>00706     <span class="comment">// Parameterized Class CCfits::FITSUtil::auto_array_ptr </span>
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     <span class="comment">// Parameterized Class CCfits::FITSUtil::ComparePtrIndex </span>
<a name="l00709"></a>00709 
<a name="l00710"></a>00710     <span class="comment">// Parameterized Class CCfits::FITSUtil::CAarray </span>
<a name="l00711"></a>00711 
<a name="l00712"></a>00712     <span class="comment">// Parameterized Class CCfits::FITSUtil::CVAarray </span>
<a name="l00713"></a>00713 
<a name="l00714"></a>00714     <span class="comment">// Class CCfits::FITSUtil::UnrecognizedType </span>
<a name="l00715"></a>00715 
<a name="l00716"></a>00716     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchPtrName </span>
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchName </span>
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchNum </span>
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchType </span>
<a name="l00723"></a>00723 
<a name="l00724"></a>00724     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00725"></a>00725     <a class="code" href="namespaceCCfits.html#a1291594525d4e6fd06698c98a7a7ec2f" title="CCfits value types and their CFITSIO equivalents (in caps)">ValueType</a> MatchType&lt;T&gt;::operator () ()
<a name="l00726"></a>00726     {
<a name="l00727"></a>00727 
<a name="l00728"></a>00728     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(d1) ) <span class="keywordflow">return</span> Tdouble;
<a name="l00729"></a>00729     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(f1) ) <span class="keywordflow">return</span> Tfloat;
<a name="l00730"></a>00730     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(c1) ) <span class="keywordflow">return</span> Tcomplex;
<a name="l00731"></a>00731     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(d2) ) <span class="keywordflow">return</span> Tdblcomplex;
<a name="l00732"></a>00732     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(s1) ) <span class="keywordflow">return</span> Tstring;
<a name="l00733"></a>00733     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(i1) ) <span class="keywordflow">return</span> Tint;
<a name="l00734"></a>00734     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(u1) ) <span class="keywordflow">return</span> Tuint;
<a name="l00735"></a>00735     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(s2) ) <span class="keywordflow">return</span> Tshort;
<a name="l00736"></a>00736     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(us1) ) <span class="keywordflow">return</span> Tushort;
<a name="l00737"></a>00737     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(b1) ) <span class="keywordflow">return</span> Tlogical;
<a name="l00738"></a>00738     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(b2) ) <span class="keywordflow">return</span> Tbyte;
<a name="l00739"></a>00739     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(l1) ) <span class="keywordflow">return</span> Tlong;
<a name="l00740"></a>00740     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(ul1) ) <span class="keywordflow">return</span> Tulong;
<a name="l00741"></a>00741     <span class="comment">// Carefull, on some compilers LONGLONG == long,</span>
<a name="l00742"></a>00742     <span class="comment">// so this should go after test for long.</span>
<a name="l00743"></a>00743     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(ll1) ) <span class="keywordflow">return</span> Tlonglong;
<a name="l00744"></a>00744     <span class="keywordflow">throw</span> UnrecognizedType(<span class="stringliteral">&quot;Invalid data type for FITS Data I/O\n&quot;</span>);    
<a name="l00745"></a>00745     }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747     <span class="comment">// Parameterized Class CCfits::FITSUtil::CVarray </span>
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchImageType </span>
<a name="l00750"></a>00750 
<a name="l00751"></a>00751     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00752"></a>00752     ImageType MatchImageType&lt;T&gt;::operator () ()
<a name="l00753"></a>00753     {
<a name="l00754"></a>00754     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(b2) ) <span class="keywordflow">return</span> Ibyte;    
<a name="l00755"></a>00755     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(s2) ) <span class="keywordflow">return</span> Ishort;
<a name="l00756"></a>00756     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(l1) ) <span class="keywordflow">return</span> Ilong;
<a name="l00757"></a>00757     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(f1) ) <span class="keywordflow">return</span> Ifloat;
<a name="l00758"></a>00758     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(d1) ) <span class="keywordflow">return</span> Idouble;
<a name="l00759"></a>00759     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(us1) ) <span class="keywordflow">return</span> Iushort;
<a name="l00760"></a>00760     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(ul1) ) <span class="keywordflow">return</span> Iulong;
<a name="l00761"></a>00761     <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>(T) == <span class="keyword">typeid</span>(ll1) ) <span class="keywordflow">return</span> Ilonglong;
<a name="l00762"></a>00762     MatchType&lt;T&gt; errType;
<a name="l00763"></a>00763     <span class="keywordtype">string</span> diag (<span class="stringliteral">&quot;Image: &quot;</span>);
<a name="l00764"></a>00764     diag += FITSType2String(errType());
<a name="l00765"></a>00765     <span class="keywordflow">throw</span> UnrecognizedType(diag);        
<a name="l00766"></a>00766     }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768     <span class="comment">// Parameterized Class CCfits::FITSUtil::MatchPtrNum </span>
<a name="l00769"></a>00769 
<a name="l00770"></a>00770     <span class="comment">// Parameterized Class CCfits::FITSUtil::auto_array_ptr </span>
<a name="l00771"></a>00771 
<a name="l00772"></a>00772     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00773"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#aa7eff76215f0bd5ac0aec23c39b903fe">00773</a>     <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#aa7eff76215f0bd5ac0aec23c39b903fe" title="constructor. allows creation of pointer to null, can be modified by reset()">auto_array_ptr&lt;X&gt;::auto_array_ptr</a> (X* p) <span class="keywordflow">throw</span> ()
<a name="l00774"></a>00774           : m_p(p)
<a name="l00775"></a>00775     {
<a name="l00776"></a>00776     }
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00779"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a3be729bfbf66a839903e92cfa0301b21">00779</a>     <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#aa7eff76215f0bd5ac0aec23c39b903fe" title="constructor. allows creation of pointer to null, can be modified by reset()">auto_array_ptr&lt;X&gt;::auto_array_ptr</a> (<a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html" title="A class that mimics the std:: library auto_ptr class, but works with arrays.">auto_array_ptr&lt;X&gt;</a>&amp; right) <span class="keywordflow">throw</span> ()
<a name="l00780"></a>00780           : m_p(right.release())
<a name="l00781"></a>00781     {
<a name="l00782"></a>00782     }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 
<a name="l00785"></a>00785     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00786"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a53dbf2f60ac2851b86b70dad5619b862">00786</a>     <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a53dbf2f60ac2851b86b70dad5619b862" title="destructor.">auto_array_ptr&lt;X&gt;::~auto_array_ptr</a>()
<a name="l00787"></a>00787     {
<a name="l00788"></a>00788       <span class="keyword">delete</span> [] m_p;
<a name="l00789"></a>00789     }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 
<a name="l00792"></a>00792     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00793"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a13ae387ac0d5d498974cc05d5ff878ae">00793</a>     <span class="keywordtype">void</span> <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a13ae387ac0d5d498974cc05d5ff878ae" title="assignment operator: transfer of ownership semantics">auto_array_ptr&lt;X&gt;::operator = </a>(<a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html" title="A class that mimics the std:: library auto_ptr class, but works with arrays.">auto_array_ptr&lt;X&gt;</a>&amp; right)
<a name="l00794"></a>00794     {
<a name="l00795"></a>00795       <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;right)
<a name="l00796"></a>00796       {
<a name="l00797"></a>00797                 <span class="keyword">remove</span>(m_p);
<a name="l00798"></a>00798                 m_p = right.<a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a994e12743b5b7d75b4168ac095a60c1f" title="return underlying content of *this, transferring memory ownership">release</a>();       
<a name="l00799"></a>00799       }
<a name="l00800"></a>00800     }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00803"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a46abc946300c6b7deaa7e456ba9f1aed">00803</a>     X&amp; <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a46abc946300c6b7deaa7e456ba9f1aed" title="deference operator">auto_array_ptr&lt;X&gt;::operator * </a>() throw ()
<a name="l00804"></a>00804     {
<a name="l00805"></a>00805       <span class="keywordflow">return</span> *m_p;
<a name="l00806"></a>00806     }
<a name="l00807"></a>00807 
<a name="l00808"></a>00808     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00809"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a114a298f4d870f74ed1039c6ee41b2b5">00809</a>     X&amp; <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a114a298f4d870f74ed1039c6ee41b2b5" title="return a reference to the ith element of the array">auto_array_ptr&lt;X&gt;::operator [] </a>(<span class="keywordtype">size_t</span> i) <span class="keywordflow">throw</span> ()
<a name="l00810"></a>00810     {
<a name="l00811"></a>00811       <span class="keywordflow">return</span> m_p[i];
<a name="l00812"></a>00812     }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00815"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a71fed8548c3d114a231a3ea87f35e218">00815</a>     X <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a114a298f4d870f74ed1039c6ee41b2b5" title="return a reference to the ith element of the array">auto_array_ptr&lt;X&gt;::operator [] </a>(<span class="keywordtype">size_t</span> i) <span class="keyword">const</span> <span class="keywordflow">throw</span> ()
<a name="l00816"></a>00816     {
<a name="l00817"></a>00817       <span class="keywordflow">return</span> m_p[i];
<a name="l00818"></a>00818     }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00821"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a6cf9e51e5dd7a9d9d512900465c5ea1f">00821</a>     X* <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a6cf9e51e5dd7a9d9d512900465c5ea1f" title="return a token for the underlying content of *this">auto_array_ptr&lt;X&gt;::get</a> ()<span class="keyword"> const</span>
<a name="l00822"></a>00822 <span class="keyword">    </span>{
<a name="l00823"></a>00823       <span class="keywordflow">return</span> m_p;
<a name="l00824"></a>00824     }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00827"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a994e12743b5b7d75b4168ac095a60c1f">00827</a>     X* <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a994e12743b5b7d75b4168ac095a60c1f" title="return underlying content of *this, transferring memory ownership">auto_array_ptr&lt;X&gt;::release</a> () throw ()
<a name="l00828"></a>00828     {
<a name="l00829"></a>00829       <span class="keywordflow">return</span> reset(0);
<a name="l00830"></a>00830     }
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00833"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#af2e65ee8fafdd812f2782da2dfea285a">00833</a>     X* <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#af2e65ee8fafdd812f2782da2dfea285a" title="change the content of the auto_array_ptr to p">auto_array_ptr&lt;X&gt;::reset</a> (X* p) <span class="keywordflow">throw</span> ()
<a name="l00834"></a>00834     {
<a name="l00835"></a>00835       <span class="comment">// set the auto_ptr to manage p and return the old pointer it was managing.</span>
<a name="l00836"></a>00836       X* __tmp = m_p; 
<a name="l00837"></a>00837       m_p = p;
<a name="l00838"></a>00838       <span class="keywordflow">return</span> __tmp;
<a name="l00839"></a>00839     }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;
<a name="l00842"></a><a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a13ca62c9f81dbc710968b2afae2d18a7">00842</a>     <span class="keywordtype">void</span> <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a13ca62c9f81dbc710968b2afae2d18a7" title="utility function to delete the memory owned by x and set it to null.">auto_array_ptr&lt;X&gt;::remove</a> (X*&amp; x)
<a name="l00843"></a>00843     {
<a name="l00844"></a>00844       X* __tmp(x);
<a name="l00845"></a>00845       x = 0;
<a name="l00846"></a>00846       <span class="keyword">delete</span> [] __tmp;
<a name="l00847"></a>00847     }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849     <span class="comment">// Parameterized Class CCfits::FITSUtil::ComparePtrIndex </span>
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00852"></a>00852     <span class="keywordtype">bool</span> ComparePtrIndex&lt;T&gt;::operator () (<span class="keyword">const</span> T* left, <span class="keyword">const</span> T* right)
<a name="l00853"></a>00853     {
<a name="l00854"></a>00854       <span class="keywordflow">return</span> (left-&gt;index() &lt; right-&gt;index());
<a name="l00855"></a>00855     }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857     <span class="comment">// Parameterized Class CCfits::FITSUtil::CAarray </span>
<a name="l00858"></a>00858 
<a name="l00859"></a>00859     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00860"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1CAarray.html#a696f1168e9058a218e91ea0ead06693f">00860</a>     T* <a class="code" href="structCCfits_1_1FITSUtil_1_1CAarray.html#a696f1168e9058a218e91ea0ead06693f" title="operator returning C array for use with image data.">CAarray&lt;T&gt;::operator () </a>(<span class="keyword">const</span> std::valarray&lt;T&gt;&amp; inArray)
<a name="l00861"></a>00861     {
<a name="l00862"></a>00862       <span class="keywordtype">size_t</span> n(inArray.size());
<a name="l00863"></a>00863       <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html" title="A class that mimics the std:: library auto_ptr class, but works with arrays.">auto_array_ptr&lt;T&gt;</a> pC(<span class="keyword">new</span> T[n]);
<a name="l00864"></a>00864       T* c= pC.get();
<a name="l00865"></a>00865       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; n; ++j) c[j] = inArray[j];
<a name="l00866"></a>00866       <span class="keywordflow">return</span> pC.release();      
<a name="l00867"></a>00867     }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     <span class="comment">// Parameterized Class CCfits::FITSUtil::CVAarray </span>
<a name="l00870"></a>00870 
<a name="l00871"></a>00871     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00872"></a><a class="code" href="structCCfits_1_1FITSUtil_1_1CVAarray.html#a817543d5a8700ca336a35e62a3223d12">00872</a>     T* <a class="code" href="structCCfits_1_1FITSUtil_1_1CVAarray.html#a817543d5a8700ca336a35e62a3223d12" title="operator returning C array for use with vector column data.">CVAarray&lt;T&gt;::operator () </a>(<span class="keyword">const</span> std::vector&lt; std::valarray&lt;T&gt; &gt;&amp; inArray)
<a name="l00873"></a>00873     {
<a name="l00874"></a>00874       <span class="keywordtype">size_t</span>  sz(0);
<a name="l00875"></a>00875       <span class="keywordtype">size_t</span>  n(inArray.size());
<a name="l00876"></a>00876 
<a name="l00877"></a>00877       std::vector&lt;size_t&gt; nr(n);
<a name="l00878"></a>00878 
<a name="l00879"></a>00879       <span class="keywordtype">size_t</span> i = 0; <span class="comment">// for MS VC++ bug</span>
<a name="l00880"></a>00880       <span class="keywordflow">for</span> ( i = 0; i &lt; n; ++i)
<a name="l00881"></a>00881       {
<a name="l00882"></a>00882          nr[i] = inArray[i].size();
<a name="l00883"></a>00883          sz += nr[i];
<a name="l00884"></a>00884 
<a name="l00885"></a>00885       }
<a name="l00886"></a>00886       <a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html" title="A class that mimics the std:: library auto_ptr class, but works with arrays.">auto_array_ptr&lt;T&gt;</a> pC(<span class="keyword">new</span> T[sz]);
<a name="l00887"></a>00887       T* c = pC.<a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a6cf9e51e5dd7a9d9d512900465c5ea1f" title="return a token for the underlying content of *this">get</a>();
<a name="l00888"></a>00888 
<a name="l00889"></a>00889       <span class="keywordtype">size_t</span> k(0);
<a name="l00890"></a>00890       <span class="keywordflow">for</span> ( i = 0; i &lt; n; ++i)
<a name="l00891"></a>00891       {
<a name="l00892"></a>00892          <span class="keywordtype">size_t</span>&amp; m = nr[i];
<a name="l00893"></a>00893          <span class="keyword">const</span> std::valarray&lt;T&gt;&amp; current = inArray[i];
<a name="l00894"></a>00894          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j &lt; m ; ++j) c[k++] = current[j];
<a name="l00895"></a>00895       }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897       <span class="keywordflow">return</span> pC.<a class="code" href="classCCfits_1_1FITSUtil_1_1auto__array__ptr.html#a994e12743b5b7d75b4168ac095a60c1f" title="return underlying content of *this, transferring memory ownership">release</a>();      
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   } <span class="comment">// namespace FITSUtil</span>
<a name="l00901"></a>00901 } <span class="comment">// namespace CCfits</span>
<a name="l00902"></a>00902 
<a name="l00903"></a>00903 <span class="keyword">namespace </span>CCfits
<a name="l00904"></a>00904 {
<a name="l00905"></a>00905 
<a name="l00906"></a>00906    <span class="keyword">namespace </span>FITSUtil
<a name="l00907"></a>00907    {                
<a name="l00908"></a>00908 
<a name="l00909"></a>00909       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00910"></a>00910       <span class="keywordtype">void</span> swap(T&amp; left, T&amp; right)
<a name="l00911"></a>00911       {
<a name="l00912"></a>00912               T temp(left);
<a name="l00913"></a>00913               left = right;
<a name="l00914"></a>00914               right = temp;                
<a name="l00915"></a>00915       }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00918"></a>00918       <span class="keywordtype">void</span> swap(std::vector&lt;T&gt;&amp; left, std::vector&lt;T&gt;&amp; right)
<a name="l00919"></a>00919       {
<a name="l00920"></a>00920               left.swap(right);        
<a name="l00921"></a>00921       }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923       <span class="keyword">template</span> &lt;&gt;
<a name="l00924"></a>00924       <span class="keyword">inline</span> <span class="keywordtype">string</span> FitsNullValue&lt;string&gt;::operator () ()
<a name="l00925"></a>00925       {
<a name="l00926"></a>00926          <span class="keywordflow">return</span> string(<span class="stringliteral">&quot;&quot;</span>);
<a name="l00927"></a>00927       }
<a name="l00928"></a>00928       
<a name="l00929"></a>00929       <span class="keyword">template</span> &lt;&gt;
<a name="l00930"></a>00930       <span class="keyword">inline</span> <span class="keywordtype">float</span> FitsNullValue&lt;float&gt;::operator () ()
<a name="l00931"></a>00931       {
<a name="l00932"></a>00932          <span class="keywordflow">return</span> FLOATNULLVALUE;
<a name="l00933"></a>00933       }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935       <span class="keyword">template</span> &lt;&gt;
<a name="l00936"></a>00936       <span class="keyword">inline</span> <span class="keywordtype">double</span> FitsNullValue&lt;double&gt;::operator () ()
<a name="l00937"></a>00937       {
<a name="l00938"></a>00938          <span class="keywordflow">return</span> DOUBLENULLVALUE;
<a name="l00939"></a>00939       }
<a name="l00940"></a>00940       
<a name="l00941"></a>00941       <span class="keyword">template</span> &lt;&gt;
<a name="l00942"></a>00942       <span class="keyword">inline</span> std::complex&lt;float&gt; FitsNullValue&lt;std::complex&lt;float&gt; &gt;::operator () ()
<a name="l00943"></a>00943       {
<a name="l00944"></a>00944          <span class="keywordflow">return</span> std::complex&lt;float&gt;(FLOATNULLVALUE);
<a name="l00945"></a>00945       }
<a name="l00946"></a>00946 
<a name="l00947"></a>00947       <span class="keyword">template</span> &lt;&gt;
<a name="l00948"></a>00948       <span class="keyword">inline</span> std::complex&lt;double&gt; FitsNullValue&lt;std::complex&lt;double&gt; &gt;::operator () ()
<a name="l00949"></a>00949       {
<a name="l00950"></a>00950          <span class="keywordflow">return</span> std::complex&lt;double&gt;(DOUBLENULLVALUE);
<a name="l00951"></a>00951       }
<a name="l00952"></a>00952       
<a name="l00953"></a>00953    } <span class="comment">// end namespace FITSUtil</span>
<a name="l00954"></a>00954 } <span class="comment">// end namespace CCfits</span>
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 14 2016 15:57:19 for CCfits by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
