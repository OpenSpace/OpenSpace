<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CCfits: Creating and Writing to a Binary Table Extension</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CCfits
   &#160;<span id="projectnumber">2.5</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Creating and Writing to a Binary Table Extension </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>The Binary Table interface is more complex because there is an additional parameter, the vector size of each `cell' in the table, the need to support variable width columns, and the desirability of supporting the input of data in various formats.</p>
<p>The interface supports writing to vector tables the following data structures: C-arrays (T*), std::vector&lt;T&gt; objects, std::valarray&lt;T&gt; objects, and std::vector&lt;valarray&lt;T&gt; &gt;. The last of these is the internal representation of the data.</p>
<p>The function below exercises the following functionality:</p>
<ul>
<li>Create a BinTable extension</li>
<li>Write vector rows to the table</li>
<li>Insert table rows</li>
<li>Write complex data to both scalar and vector columns.</li>
<li>Insert Table columns</li>
<li>Delete Table rows</li>
<li>Write HISTORY and COMMENT cards to the Table</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> writeBinary ()

    <span class="comment">//*********************************************************************</span>
    <span class="comment">// Create a BINARY table extension and write and manipulate vector rows </span>
    <span class="comment">//*********************************************************************</span>
{
    std::auto_ptr&lt;FITS&gt; pFits(0);
      
    <span class="keywordflow">try</span>
    {                
            
        <span class="keyword">const</span> std::string fileName(<span class="stringliteral">&quot;atestfil.fit&quot;</span>);        
        pFits.reset( <span class="keyword">new</span> FITS(fileName,Write) );
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classCCfits_1_1FITS_1_1CantOpen.html" title="thrown on failure to open existing file">CCfits::FITS::CantOpen</a>)
    {
          <span class="keywordflow">return</span> -1;       
    }
    
        
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rows(3);     
    <span class="keywordtype">string</span> hduName(<span class="stringliteral">&quot;TABLE_BINARY&quot;</span>);          
    std::vector&lt;string&gt; colName(7,<span class="stringliteral">&quot;&quot;</span>);
    std::vector&lt;string&gt; colForm(7,<span class="stringliteral">&quot;&quot;</span>);
    std::vector&lt;string&gt; colUnit(7,<span class="stringliteral">&quot;&quot;</span>);
    
    
    colName[0] = <span class="stringliteral">&quot;numbers&quot;</span>;
    colName[1] = <span class="stringliteral">&quot;sequences&quot;</span>;
    colName[2] = <span class="stringliteral">&quot;powers&quot;</span>;
    colName[3] = <span class="stringliteral">&quot;big-integers&quot;</span>;
    colName[4] = <span class="stringliteral">&quot;dcomplex-roots&quot;</span>;
    colName[5] = <span class="stringliteral">&quot;fcomplex-roots&quot;</span>;
    colName[6] = <span class="stringliteral">&quot;scalar-complex&quot;</span>;

    colForm[0] = <span class="stringliteral">&quot;8A&quot;</span>;
    colForm[1] = <span class="stringliteral">&quot;20J&quot;</span>;
    colForm[2] = <span class="stringliteral">&quot;20D&quot;</span>;
    colForm[3] = <span class="stringliteral">&quot;20V&quot;</span>;
    colForm[4] = <span class="stringliteral">&quot;20M&quot;</span>;
    colForm[5] = <span class="stringliteral">&quot;20C&quot;</span>;
    colForm[6] = <span class="stringliteral">&quot;1M&quot;</span>;

    colUnit[0] = <span class="stringliteral">&quot;magnets&quot;</span>;
    colUnit[1] = <span class="stringliteral">&quot;bulbs&quot;</span>;
    colUnit[2] = <span class="stringliteral">&quot;batteries&quot;</span>;  
    colUnit[3] = <span class="stringliteral">&quot;mulberries&quot;</span>;  
    colUnit[4] = <span class="stringliteral">&quot;&quot;</span>;  
    colUnit[5] = <span class="stringliteral">&quot;&quot;</span>;
    colUnit[6] = <span class="stringliteral">&quot;pico boo&quot;</span>;
    
    std::vector&lt;string&gt; numbers(rows);
    
    <span class="keyword">const</span> <span class="keywordtype">string</span> num(<span class="stringliteral">&quot;NUMBER-&quot;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; rows; ++j)
    {
<span class="preprocessor">#ifdef HAVE_STRSTREAM</span>
<span class="preprocessor"></span>        std::ostrstream pStr;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        std::ostringstream pStr;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        pStr &lt;&lt; num &lt;&lt; j+1;
        numbers[j] = string(pStr.str());
    }
                    
    <span class="keyword">const</span> <span class="keywordtype">size_t</span> OFFSET(20);
    
    <span class="comment">// write operations take in data as valarray&lt;T&gt;, vector&lt;T&gt; , and </span>
    <span class="comment">// vector&lt;valarray&lt;T&gt; &gt;, and T* C-arrays. Create arrays to exercise the C++</span>
    <span class="comment">// containers. Check complex I/O for both float and double complex types.</span>
   
    std::valarray&lt;long&gt; sequence(60);
    std::vector&lt;long&gt; sequenceVector(60);
    std::vector&lt;std::valarray&lt;long&gt; &gt; sequenceVV(3);
    
    
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; rows; ++j)
    {
        
        sequence[OFFSET*j] = 1 + j;
        sequence[OFFSET*j+1] = 1 + j;
        sequenceVector[OFFSET*j] = sequence[OFFSET*j];
        sequenceVector[OFFSET*j+1] = sequence[OFFSET*j+1];
        <span class="comment">// generate Fibonacci numbers.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 2; i &lt; OFFSET; ++i)
        {
                <span class="keywordtype">size_t</span> elt (OFFSET*j +i);
                sequence[elt] = sequence[elt-1] + sequence[elt - 2];
                sequenceVector[elt] = sequence[elt] ;
        }
        sequenceVV[j].resize(OFFSET);
        sequenceVV[j] = sequence[std::slice(OFFSET*j,OFFSET,1)];
         
    }
    
        
    std::valarray&lt;unsigned long&gt; unsignedData(60);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> base (1 &lt;&lt; 31);
    std::valarray&lt;double&gt; powers(60);
    std::vector&lt;double&gt; powerVector(60);
    std::vector&lt;std::valarray&lt;double&gt; &gt; powerVV(3);
    std::valarray&lt;std::complex&lt;double&gt; &gt; croots(60);
    std::valarray&lt;std::complex&lt;float&gt; &gt; fcroots(60);
    std::vector&lt;std::complex&lt;float&gt; &gt; fcroots_vector(60);
    std::vector&lt;std::valarray&lt;std::complex&lt;float&gt; &gt; &gt; fcrootv(3);
    
    <span class="comment">// create complex data as 60th roots of unity.</span>
    <span class="keywordtype">double</span> PIBY = M_PI/30.;
    
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; rows; ++j)
    {
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; OFFSET; ++i)
        {
                <span class="keywordtype">size_t</span> elt (OFFSET*j+i);
                unsignedData[elt] = sequence[elt];
                croots[elt] = std::complex&lt;double&gt;(std::cos(PIBY*elt),std::sin(PIBY*elt));
                fcroots[elt] = std::complex&lt;float&gt;(croots[elt].real(),croots[elt].imag());
                <span class="keywordtype">double</span> x = i+1;
                powers[elt] = pow(x,j+1);
                powerVector[elt] = powers[elt];
        }
        powerVV[j].resize(OFFSET);
        powerVV[j] = powers[std::slice(OFFSET*j,OFFSET,1)];
    }
    
    FITSUtil::fill(fcroots_vector,fcroots[std::slice(0,20,1)]);
    
    unsignedData += base;
    <span class="comment">// syntax identical to Binary Table</span>
    
    Table* newTable = pFits-&gt;addTable(hduName,rows,colName,colForm,colUnit);
    
    <span class="comment">// numbers is a scalar column</span>
    
    newTable-&gt;column(colName[0]).write(numbers,1);  
    
    <span class="comment">// write valarrays to vector column: note signature change</span>
    newTable-&gt;column(colName[1]).write(sequence,rows,1);
    newTable-&gt;column(colName[2]).write(powers,rows,1);
    newTable-&gt;column(colName[3]).write(unsignedData,rows,1);    
    newTable-&gt;column(colName[4]).write(croots,rows,1);    
    newTable-&gt;column(colName[5]).write(fcroots,rows,3);    
    newTable-&gt;column(colName[6]).write(fcroots_vector,1);    
    <span class="comment">// write vectors to column: note signature change</span>
    
    newTable-&gt;column(colName[1]).write(sequenceVector,rows,4);
    newTable-&gt;column(colName[2]).write(powerVector,rows,4);
    
    std::cout &lt;&lt; *newTable &lt;&lt; std::endl;
   
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; 3 ;  ++j)
    {
            fcrootv[j].resize(20);
            fcrootv[j] = fcroots[std::slice(20*j,20,1)];
    } 

    <span class="comment">// write vector&lt;valarray&gt; object to column.</span>
    
    newTable-&gt;column(colName[1]).writeArrays(sequenceVV,7);
    newTable-&gt;column(colName[2]).writeArrays(powerVV,7);

 
    
    <span class="comment">// create a new vector column in the Table</span>


    newTable-&gt;addColumn(Tfloat,<span class="stringliteral">&quot;powerSeq&quot;</span>,20,<span class="stringliteral">&quot;none&quot;</span>);

    <span class="comment">// add data entries to it.</span>

    newTable-&gt;column(<span class="stringliteral">&quot;powerSeq&quot;</span>).writeArrays(powerVV,1);
    newTable-&gt;column(<span class="stringliteral">&quot;powerSeq&quot;</span>).write(powerVector,rows,4);
    newTable-&gt;column(<span class="stringliteral">&quot;dcomplex-roots&quot;</span>).write(croots,rows,4);
    newTable-&gt;column(<span class="stringliteral">&quot;powerSeq&quot;</span>).write(sequenceVector,rows,7);
    

    std::cout &lt;&lt; *newTable &lt;&lt; std::endl;
    
    <span class="comment">// delete one of the original columns.</span>

 

    newTable-&gt;deleteColumn(colName[2]);


    <span class="comment">// add a new set of rows starting after row 3. So we&#39;ll have 14 with</span>
    <span class="comment">// rows 4,5,6,7,8 blank</span>

    newTable-&gt;insertRows(3,5);
    
    <span class="comment">// now, in the new column, write 3 rows (sequenceVV.size() = 3). This</span>
    <span class="comment">// will place data in rows 3,4,5 of this column,overwriting them.</span>
    
    newTable-&gt;column(<span class="stringliteral">&quot;powerSeq&quot;</span>).writeArrays(sequenceVV,3);
    newTable-&gt;column(<span class="stringliteral">&quot;fcomplex-roots&quot;</span>).writeArrays(fcrootv,3);

    <span class="comment">// delete 3 rows starting with row 2. A Table:: method, so the same</span>
    <span class="comment">// code is called for all Table objects. We should now have 11 rows.</span>
    
    newTable-&gt;deleteRows(2,3);
    
    <span class="comment">//add a history string. This function call is in HDU:: so is identical</span>
    <span class="comment">//for all HDUs</span>

    <span class="keywordtype">string</span> hist(<span class="stringliteral">&quot;This file was created for testing CCfits write functionality&quot;</span>);
    hist += <span class="stringliteral">&quot; it serves no other useful purpose. This particular part of the file was &quot;</span>;
    hist += <span class="stringliteral">&quot; constructed to test the writeHistory() and writeComment() functionality&quot;</span> ;

 
    newTable-&gt;writeHistory(hist);
    
    <span class="comment">// add a comment string. Use std::string method to change the text in the message</span>
    <span class="comment">// and write the previous junk as a comment.</span>

    hist.insert(0, <span class="stringliteral">&quot; COMMENT TEST &quot;</span>);

    newTable-&gt;writeComment(hist);

    <span class="comment">// ... print the result.</span>
    
    std::cout &lt;&lt; *newTable &lt;&lt; std::endl;
    
    <span class="keywordflow">return</span> 0;
}
</pre></div> </div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 14 2016 15:57:19 for CCfits by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
