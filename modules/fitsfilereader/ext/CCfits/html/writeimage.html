<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CCfits: Writing Primary Images and Image Extensions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CCfits
   &#160;<span id="projectnumber">2.5</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Writing Primary Images and Image Extensions </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This section of the code demonstrates creation of images. Because every fits file must have a PHDU element, all the FITS constructors (ctors) instantiate a PHDU object. In the case of a new file, the default is to establish an empty HDU with BITPIX = 8 (BYTE_IMG). <b><em>A current limitation of the code is that the data type of the PHDU cannot be replaced after the FITS file is created.</em></b> Arguments to the FITS ctors allow the specification of the data type and the number of axes and their lengths. An image extension of type float is also written by calls in between the writes to the primary header demonstrating switch between HDUs during writes.</p>
<p>Note that in the example below data of type <em>float </em> is written to an image of type <em>unsigned int,</em> demonstrating both implicit type conversion and the cfitsio extension to unsigned data.</p>
<p>User keywords can be added to the PHDU after successful construction and these will both be accessible as container contents in the in-memory FITS object as well as being written to disk by cfitsio.</p>
<p>Images are represented by the standard library valarray template class which supports vectorized operations on numeric arrays (e.g. taking the square root of an array) and slicing techniques.</p>
<p>The code below also illustrates use of C++ standard library algorithms, and the facilities provided by the std::valarray class.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> writeImage()
{

    <span class="comment">// Create a FITS primary array containing a 2-D image               </span>
    <span class="comment">// declare axis arrays.    </span>
    <span class="keywordtype">long</span> naxis    =   2;      
    <span class="keywordtype">long</span> naxes[2] = { 300, 200 };   
    
    <span class="comment">// declare auto-pointer to FITS at function scope. Ensures no resources</span>
    <span class="comment">// leaked if something fails in dynamic allocation.</span>
    std::auto_ptr&lt;FITS&gt; pFits(0);
      
    <span class="keywordflow">try</span>
    {                
        <span class="comment">// overwrite existing file if the file already exists.</span>
            
        <span class="keyword">const</span> std::string fileName(<span class="stringliteral">&quot;!atestfil.fit&quot;</span>);            
        
        <span class="comment">// Create a new FITS object, specifying the data type and axes for the primary</span>
        <span class="comment">// image. Simultaneously create the corresponding file.</span>
        
        <span class="comment">// this image is unsigned short data, demonstrating the cfitsio extension</span>
        <span class="comment">// to the FITS standard.</span>
        
        pFits.reset( <span class="keyword">new</span> FITS(fileName , USHORT_IMG , naxis , naxes ) );
    }
    <span class="keywordflow">catch</span> (FITS::CantCreate)
    {
          <span class="comment">// ... or not, as the case may be.</span>
          <span class="keywordflow">return</span> -1;       
    }
    
    <span class="comment">// references for clarity.</span>
    
    <span class="keywordtype">long</span>&amp; vectorLength = naxes[0];
    <span class="keywordtype">long</span>&amp; numberOfRows = naxes[1];
    <span class="keywordtype">long</span> nelements(1); 
    
    
    <span class="comment">// Find the total size of the array. </span>
    <span class="comment">// this is a little fancier than necessary ( It&#39;s only</span>
    <span class="comment">// calculating naxes[0]*naxes[1]) but it demonstrates  use of the </span>
    <span class="comment">// C++ standard library accumulate algorithm.</span>
    
    nelements = std::accumulate(&amp;naxes[0],&amp;naxes[naxis],1,std::multiplies&lt;long&gt;());
           
    <span class="comment">// create a new image extension with a 300x300 array containing float data.</span>
    
    std::vector&lt;long&gt; extAx(2,300);
    <span class="keywordtype">string</span> newName (<span class="stringliteral">&quot;NEW-EXTENSION&quot;</span>);
    ExtHDU* imageExt = pFits-&gt;addImage(newName,FLOAT_IMG,extAx);
    
    <span class="comment">// create a dummy row with a ramp. Create an array and copy the row to </span>
    <span class="comment">// row-sized slices. [also demonstrates the use of valarray slices].   </span>
    <span class="comment">// also demonstrate implicit type conversion when writing to the image:</span>
    <span class="comment">// input array will be of type float.</span>
    
    std::valarray&lt;int&gt; row(vectorLength);
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> j = 0; j &lt; vectorLength; ++j) row[j] = j;
    std::valarray&lt;int&gt; array(nelements);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numberOfRows; ++i)
    {
        array[std::slice(vectorLength*static_cast&lt;int&gt;(i),vectorLength,1)] = row + i;     
    }
    
    <span class="comment">// create some data for the image extension.</span>
    <span class="keywordtype">long</span> extElements = std::accumulate(extAx.begin(),extAx.end(),1,std::multiplies&lt;long&gt;()); 
    std::valarray&lt;float&gt; ranData(extElements);
    <span class="keyword">const</span> <span class="keywordtype">float</span> PIBY (M_PI/150.);
    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> jj = 0 ; jj &lt; extElements ; ++jj) 
    {
            <span class="keywordtype">float</span> arg = PIBY*jj;
            ranData[jj] = std::cos(arg);
    }
 
    <span class="keywordtype">long</span>  fpixel(1);
    
    <span class="comment">// write the image extension data: also demonstrates switching between</span>
    <span class="comment">// HDUs.</span>
    imageExt-&gt;write(fpixel,extElements,ranData);
    
    <span class="comment">//add two keys to the primary header, one long, one complex.</span>
    
    <span class="keywordtype">long</span> exposure(1500);
    std::complex&lt;float&gt; omega(std::cos(2*M_PI/3.),std::sin(2*M_PI/3));
    pFits-&gt;pHDU().addKey(<span class="stringliteral">&quot;EXPOSURE&quot;</span>, exposure,<span class="stringliteral">&quot;Total Exposure Time&quot;</span>); 
    pFits-&gt;pHDU().addKey(<span class="stringliteral">&quot;OMEGA&quot;</span>,omega,<span class="stringliteral">&quot; Complex cube root of 1 &quot;</span>);  

    
    <span class="comment">// The function PHDU&amp; FITS::pHDU() returns a reference to the object representing </span>
    <span class="comment">// the primary HDU; PHDU::write( &lt;args&gt; ) is then used to write the data.</span>
    
    pFits-&gt;pHDU().write(fpixel,nelements,array);
    
    
    <span class="comment">// PHDU&#39;s friend ostream operator. Doesn&#39;t print the entire array, just the</span>
    <span class="comment">// required &amp; user keywords, and is provided largely for testing purposes [see </span>
    <span class="comment">// readImage() for an example of how to output the image array to a stream].</span>
    
    std::cout &lt;&lt; pFits-&gt;pHDU() &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 14 2016 15:57:19 for CCfits by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
